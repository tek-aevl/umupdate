#!/bin/bash
SCRIPT_START=$(date +%s)
echo "#v.96# To use this in cli use
sudo nano /bin/usr/update
# copy the next 3 lines into it with, and chmod it to 755
#!/bin/bash
bash <(curl -c https://raw.githubusercontent.com/tek-aevl/umupdate/refs/heads/main/supdate)
echo 'bye'
###above###
"
echo "#To use run"
echo "bash update"
sleep 2
#############################################
echo "setting functions"
###############################################
format_time() {
    local SECONDS=$1
    printf "%02d:%02d:%02d" $((SECONDS/3600)) $((SECONDS%3600/60)) $((SECONDS%60))
}

#Function to check and copy SSH key to a remote host if needed
function copy_ssh_key() {
    if [[ ! -f ~/.ssh/id_rsa.pub ]]; then
        echo "SSH key not found. Generating a new SSH key..."
        ssh-keygen -t rsa
    fi
    # Check if the SSH key is already present on the remote host
   if ! ssh-add -L | grep -qF "$(cat ~/.ssh/id_rsa.pub)"; then
        #read -p "Enter the IP address or hostname of the remote host: " ip
       echo "Current client $ip"
        ssh-copy-id "$ip"
    else
        echo "SSH key is already copied to the remote host. No need to copy again."
    fi
}

# Function to check if Pi-hole is installed and running on a host
function check_pihole {
  # Check if the Pi-hole service is running
  if ssh -q -o ConnectTimeout=1 $1 "systemctl is-active pihole-FTL.service &> /dev/null"; then
    # Check if the Pi-hole web interface is accessible
    if curl -s -I -H "Host: pi.hole" http://$1/admin/ &> /dev/null; then
      return 0  # Pi-hole is installed and running
    fi
  fi
  return 1  # Pi-hole is not installed or not running
}
echo "...done..."

# Function to prompt the user for ARP inclusion
prompt_arp() {
    read -p "Do you want to include ARP in the IP list? (Y/N): " choice
    case "$choice" in
        [yY] | [yY][eE][sS])
            echo "Retrieving ARP table"
           if [ -f ~/arp_ip_list ]; then
           echo "ARP List"
           cat ~/arp_ip_list |less
               read -p "~/arp_ip_list already exists. Do you want to overwrite it? (y/n): " overwrite
                  if [ "$overwrite" = "y" ]; then
                   arp_ip_list=$(arp -av | awk '{print $2}' | sed 's/[()]//g')
                   echo "$arp_ip_list" > ~/arp_ip_list
                   echo "$arp_ip_list is the new list."
               #    sleep 3
                  else
                    arp_ip_list=$(<~/arp_ip_list)
                    echo "No changes made to $arp_ip_list ..."
              #      sleep 3                  
                  fi
                else
                  arp_ip_list=$(<~/arp_ip_list)
              echo " $arp_ip_list " 
              echo " .loaded. "
            #sleep 2
          fi
          echo "$arp_ip_list" 
          echo "...done..."          
           # sleep 3
            ;;
        [nN] | [nN][oO])
            arp_ip_list=""
            ;;
        *)
            echo "Invalid choice. Defaulting to no ARP."
            arp_ip_list=""
            ;;
    esac
}

prompt_arp


# Get the default route interface
default_interface=$(ip route | awk '/default/ {print $5}')

# Get the IP address and subnet mask of the default route interface
interface_info=$(ip a show dev "$default_interface" | awk '/inet\s/ {print $2}')
interface_ip=$(echo "$interface_info" | cut -d '/' -f 1)
interface_subnet=$(echo "$interface_info" | cut -d '/' -f 2)

# Calculate network address and subnet mask length
IFS='.' read -r -a ip_parts <<< "$interface_ip"
netmask_length=$(printf "%.*s1" "$interface_subnet" "11111111111111111111111111111111")
network_address=$(printf "%d.%d.%d.%d\n" "$((ip_parts[0] & 0xFF & (0xFF << (32 - interface_subnet))))" \
                                       "$((ip_parts[1] & 0xFF & (0xFF << (32 - interface_subnet))))" \
                                       "$((ip_parts[2] & 0xFF & (0xFF << (32 - interface_subnet))))" \
                                       "$((ip_parts[3] & 0xFF & (0xFF << (32 - interface_subnet))))")

# Get the list of clients on the same subnet as the default route interface
bridge_clients_default=$(ip neigh show dev "$default_interface" | awk -v network="$network_address" '{if ($1 ~ network) print $1}')
echo "Bridge clients on the same subnet as the default route interface ($default_interface):"
echo "$bridge_clients_default" | more 
echo "Retrieving active clients over the bridge"
# Retrieve active clients in the bridge
bridge_clients=$(ip neigh show dev virbr0 | awk '{print $1}') && echo $bridge_clients
echo "$bridge_clients ...done..."
#sleep 2

echo "Retrieve Tailscale client IP addresses"
# Retrieve Tailscale client IP addresses from 'tailscale status' command
##old# tailscale_ip_list=$(tailscale status | grep -oE '10\.[0-9]+\.[0-9]+\.[0-9]+')
tailscale_ip_list=$(sudo tailscale status | grep -Eo '100\.[0-9]+\.[0-9]+\.[0-9]+' | awk '!seen[$0]++')
echo "Tailscale Client List"
echo "$tailscale_ip_list"
echo ".!.done.!."
#sleep 2

echo "Retrieving custom_ip_list"
# custom list put the next line in a new file called custom_ip_list
#custom_ip_list="0.0.0.0"$'\n'"0.0.0.0"
custom_ip_list=$(grep -E -o '([0-9]{1,3}\.){3}[0-9]{1,3}' ~/custom_ip_list)
cat ~/custom_ip_list
echo "custom_list" && sleep 2
echo "$custom_ip_list  ...done..."
#sleep 2

echo "Retrieving ignore_ip_list"
ignore_ip_list=$(grep -E -o '([0-9]{1,3}\.){3}[0-9]{1,3}' ~/ignore_ip_list)

# Check if there are any IP addresses found before creating the file
if [[ -n "$ignore_ip_list" ]]; then
    # Use printf for better portability and to handle special characters properly
    printf "%s\n" "$ignore_ip_list" > ~/ignore_list.txt
fi

echo "ignore list created" 
#sleep 2

# Combine the IP lists based on user choice
if [ -n "$arp_ip_list" ]; then
    ip_list="$bridge_clients_default"$'\n'"$bridge_clients"$'\n'"$custom_ip_list"$'\n'"$arp_ip_list"$'\n'"$tailscale_ip_list"
else
    ip_list="$bridge_clients_default"$'\n'"$bridge_clients"$'\n'"$custom_ip_list"$'\n'"$tailscale_ip_list"
fi


echo "$ip_list ...ip list..."
#sleep 2

echo "Removing IPs listed in the ignore list sorting then removing duplicates"
while IFS= read -r ip; do
    ip_list=$(echo "$ip_list" | grep -vFx "$ip")
done < ignore_list.txt

echo "$ip_list ...ip list..."

# Step 4: Output the final combined list
echo "#####Final combined list:#####"
echo '"$ip_list" | less'
echo "$ip_list"
echo '$ip_list | less'
echo ";-P"
sleep 3

##bad## ip_list=$(echo "$ip_list" | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort -u)

# CLEAN LIST AGAIN JUST IN CASE
###old## ip_list=$(echo "$ip_list" | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort -u)
##new
ip_list=$(echo "$ip_list" \
    | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' \
    | sort -t . -k1,1n -k2,2n -k3,3n -k4,4n \
    | uniq)

TOTAL=$(echo "$ip_list" | wc -l)

###############################################################
# INIT ARRAYS FOR UI
###############################################################

ALL_IPS=($ip_list)
DONE_IPS=()
REMAINING_IPS=("${ALL_IPS[@]}")
TOTAL=${#ALL_IPS[@]}

sleep 6

###############################################################
# PROGRESS UI
###############################################################

show_progress() {
    local current="$1"
    local total="$2"
    local ip="$3"

    CY=$'\e[36m'
    GR=$'\e[32m'
    YE=$'\e[33m'
    BL=$'\e[34m'
    NC=$'\e[0m'
    RD=$'\e[31m'
    OR=$'\e[38;5;208m'
    WH=$'\e[97m'        # White (bright)
    GY=$'\e[90m'        # Grey

    REMAINING_IPS=()
    for x in "${ALL_IPS[@]}"; do
        if ! printf "%s\n" "${DONE_IPS[@]}" | grep -qx "$x"; then
            REMAINING_IPS+=("$x")
        fi
    done

    echo -e "${RD}===== SUPDATE PROGRESS =====${NC}"
    echo -e "${RD}Current: [$current/$total]  $ip${NC}"
    echo

    echo -e "${GR}=== Completed ===${NC}"
    if ((${#DONE_IPS[@]} == 0)); then
        echo -e "  ${CY}(none yet)${NC}"
    else
 
for d in "${DONE_IPS[@]}"; do
    if [[ "$d" == "$ip" ]]; then
        echo -e " ${GR}Established ${RD} >> ${OR} ${d}${NC}"
    else
        echo -e "  ${BL}${d}${NC}"
    fi
done
    fi
    echo

    echo -e "${YE}=== Remaining ===${NC}"
    if ((${#REMAINING_IPS[@]} == 0)); then
        echo -e "  ${GR}(done!)${NC}"
    else
        for r in "${REMAINING_IPS[@]}"; do
            echo -e "  ${CY}${r}${NC}"
        done
    fi

sleep 6
    echo
}



read -p "Run program-checker after updates? (y/N): " RUN_PC
RUN_PC=$(echo "$RUN_PC" | tr 'A-Z' 'a-z')

echo "Running updates!"
#max 1 Probably
#PARALLEL=1
#echo "parallel=$PARALLEL"
#sleep 2

# ip_list=$(echo "$ip_list" | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort -u) 

# INIT ARRAYS FOR UI (REQUIRED)
ALL_IPS=($ip_list)
DONE_IPS=()
REMAINING_IPS=("${ALL_IPS[@]}")
TOTAL=${#ALL_IPS[@]}


###############################################################
# RUN HOST
###############################################################


run_host() {
    local num="$1"
    local ip="$2"

# slice remaining
# num starts at 1, array starts at 0
    local idx=$(( num - 1 ))

    # remaining = from next element
    REMAINING_IPS=("${ALL_IPS[@]:$((idx + 1))}")

    # Show the UI
    show_progress "$num" "$TOTAL" "$ip"

    echo "${GR}[$num/$TOTAL] $ip → connecting...${NC}"
    sleep 1
    if check_pihole "$ip"; then
      ssh -tY $ip "bash <(curl -s https://raw.githubusercontent.com/tek-aevl/umupdate/refs/heads/main/rpi-update)"
     echo "[$num/$TOTAL] $ip → Used Remote script. RPI detected Moving on!"    
    else
        if ssh -tY $ip "bash <(curl -s https://raw.githubusercontent.com/tek-aevl/umupdate/refs/heads/main/update)"; then
            echo "[$num/$TOTAL] $ip → Used Remote script. Moving on!"
        else
    ssh -tt "$ip" "bash /bin/update"
     echo "[$num/$TOTAL] $ip → Used local script. Going to next one!"        
        fi
    fi

    # run program-checker if selected
    if [[ "$RUN_PC" == "y" ]]; then
        echo "[$num/$TOTAL] $ip → running program-checker..."
        ssh -tY "$ip" \
            "curl -s https://raw.githubusercontent.com/tek-aevl/umupdate/refs/heads/main/program-checker | bash"
    fi
   # Update progress arrays
    DONE_IPS+=("$ip")

ELAPSED=$(( $(date +%s) - SCRIPT_START ))
echo -e "${GY}Runtime: $(format_time $ELAPSED)${NC}"
echo
}

export -f run_host
export -f check_pihole
export -f show_progress
export TOTAL


###############################################################
#  EXECUTION
###############################################################

n=1
for ip in "${ALL_IPS[@]}"; do
    run_host "$n" "$ip"
    ((n++))
done

SCRIPT_END=$(date +%s)
TOTAL_RUNTIME=$((SCRIPT_END - SCRIPT_START))

echo
echo "=========================================="
echo "      SUPDATE FINISHED"
echo "      Total runtime: $(format_time $TOTAL_RUNTIME)"
echo "=========================================="
